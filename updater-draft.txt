include shared-gdrive("updater-definitions.arr", "19r6H4ZtedGt2ARtWQo1HflN0Ok8vxixJ")

provide:
find-cursor, get-node-val, update, to-tree, left, right, up, down, is-Cursor,
    type Cursor,
    end

    include my-gdrive("updater-common.arr")
# END HEADER
# DO NOT CHANGE ANYTHING ABOVE THIS LINE
#
# You may write implementation-specific tests (e.g., of helper functions) in this file.

# You will come up with a Cursor definition, which may have more than
# one variant, and can have whatever fields you need


    data Cursor<A>: 
# NO INDEX
# cursor(around :: Tree<A>, below :: Tree<A>)
# WITH INDEX
| cursor(around :: Tree<A>, below :: Tree<A>)
    end


#|
    find-cur(bloew, around, pred):

        check:
not => node(f, find-around(f.children, pred))
    pred => 

    cursor:
above: above: children: 
left left left left, pred 


[left, above, right]
|#
fun find-below-in-list<A>(childs :: List<Tree<A>>, pred :: (A -> Boolean)) -> Tree<A>:
cases (List<Tree<A>>) childs:
| empty => mt
| link(f, r) =>
cases (Tree<A>) f:
| mt => mt
| node(v, c) =>
ask:
| pred(v) then:
f # No the whole tree yet
| otherwise:
s = find-below-in-list(c, pred)
    cases (Tree<A>) s:
    | mt =>
find-below-in-list(r, pred)
    | node(_, _) =>
    s
    end
    end
    end
    end
    where:
    is-2 = {(x): x == 2 }

    find-below-in-list(empty, is-2) is mt
find-below-in-list([list: tree-1], is-2) is node(2, empty)
    find-below-in-list([list: subnode-1], is-2) is subnode-1
    end

    fun find-around-in-list<A>(childs :: List<Tree<A>>, pred):
        childs.first
        end
        fun find-cursor<A>(tree :: Tree<A>, pred :: (A -> Boolean)) -> Cursor<A>:
#|ask:
        | pred(tree.value) then:
cursor(find-around(tree, pred), tree)
    | otherwise:
    b = find-below-in-list(tree.children, pred)
cursor(find-around(b, pred), b)
    end|#
cursor(find-around-in-list([list: tree], pred),
        find-below-in-list([list : tree], pred))
    where:
#predicate:
    is-2 = lam(x): x == 2 end

                   find-cursor(mt-tree, is-2) raises "Could not find node matching predicate" 
    find-cursor(tree-1, is-2) is 
    cursor(
            node(1, 
                [list: node(3, empty)]),node(2, empty))
    find-cursor(tree-2root, is-2) is
cursor(mt, tree-2root)
    find-cursor(tree-3root, is-2) raises "s"
    find-cursor(tree-2, is-2) is
cursor(node(1, [list: subnode-2]), subnode-1) 
    end

    fun up<A>(cur :: Cursor<A>) -> Cursor<A>:
    ...
    end

    fun left<A>(cur :: Cursor<A>) -> Cursor<A>:
    ...
    end

    fun right<A>(cur :: Cursor<A>) -> Cursor<A>:
    ...
    end

    fun down<A>(cur :: Cursor<A>, child-index :: Number ) -> Cursor<A>:
    ...
    end

    fun update<A>(cur :: Cursor<A>, func :: (Tree<A> -> Tree<A>)) -> Cursor<A>:
    ...
    end

    fun to-tree<A>( cur :: Cursor<A> ) -> Tree<A>:
    ...
    end

    fun get-node-val<A>(cur :: Cursor<A>) -> Option<A>: 
    ...
    end

