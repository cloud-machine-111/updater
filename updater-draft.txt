include shared-gdrive("updater-definitions.arr", "19r6H4ZtedGt2ARtWQo1HflN0Ok8vxixJ")

provide:
  find-cursor, get-node-val, update, to-tree, left, right, up, down, is-Cursor,
  type Cursor,
end

include my-gdrive("updater-common.arr")
# END HEADER
# DO NOT CHANGE ANYTHING ABOVE THIS LINE
#
# You may write implementation-specific tests (e.g., of helper functions) in this file.

# You will come up with a Cursor definition, which may have more than
# one variant, and can have whatever fields you need

data Cursor<A>: 
  | cursor(above :: Tree<A>, below :: Tree<A>, around :: Tree<A>)
end

empty-cursor = cursor(mt, mt, node(-99, empty))

fun find-all-in-list<A>(
    childs :: List<Tree<A>>, 
    pred :: (A -> Boolean), 
    curr-parents :: List<Tree<A>>,
    curr-lefties :: List<Tree<A>>)
  -> {Tree<A>; List<Tree<A>>; List<Tree<A>>; List<Tree<A>>}:
  doc: ```
       desc: Depth-first search through the trees till you find an element for
       which a predicate is true and partition the tree around it into
       tree rooted at its (grand)parents, left siblings, right siblings, and iself
       
       parameters used for input (provides new information):
       {{childs}}: list of trees to apply the algorithm to
       {{pred}}: predicate to apply to find the pivot node
       
       parameters to save important info about current state:
       {{curr-parents}}: used to store the current parents of the pivot node
       {{curr-lefties}}: used to store the current left-siblings of the pivot node
       
       return: a tuple storing the pivot tree and its (grand)parents, left and right siblings.
       ```
  cases (List<Tree<A>>) childs:
    | empty => {mt; empty; empty; empty}
    | link(f, r) =>
      cases (Tree<A>) f:
        | mt => {mt; empty; empty; empty}
        | node(v, c) =>
          ask:
            | pred(v) then:
              {f; curr-parents; r; curr-lefties} # No the whole tree yet
            | otherwise:
              {dwn; upp; rght; lft} = 
                find-all-in-list(c, pred, link(f, curr-parents), empty)
              cases (Tree<A>) dwn:
                |  mt =>
                  find-all-in-list(r, pred, curr-parents,link(f, curr-lefties))
                | node(_, _) =>
                  {dwn; upp; rght; lft}
              end
          end
      end
  end
where:

  find-all-in-list(empty, is-2, empty, empty) 
    is {mt; empty; empty; empty}

  find-all-in-list(
    [list: tree-1], is-2, [list: node(".", [list: tree-1])], empty)
    is {
    node(2, empty); 
    [list: tree-1, node(".", [list : tree-1])];
    [list: node(3, empty)];
    empty}

  find-all-in-list(
    [list: subnode-2root], is-2, [list: node(".", [list: subnode-2root])], empty)
    is {
    subnode-2root; 
    [list: node(".", [list : subnode-2root])];
    empty;
    empty}

  find-all-in-list([list: tree-2], is-2, [list: node(".", [list: tree-2])], empty) 
    is {
    subnode-2root; 
    [list: tree-2, node(".", [list: tree-2])];
    [list: subnode-3root];
    empty}
  
  find-all-in-list([list: tree-3], is-2, [list: node(".", [list : tree-3])], empty)
    is {
    subnode-2root;
    [list: tree-3, node(".", [list : tree-3])];
    [list: subnode-3root];
    [list: subnode-no-2];
  }
end


fun find-cursor<A>(tree :: Tree<A>, pred :: (A -> Boolean)) -> Cursor<A>:
  ...
end


fun up<A>(cur :: Cursor<A>) -> Cursor<A>:
  ...
end

fun left<A>(cur :: Cursor<A>) -> Cursor<A>:
  ...
end

fun right<A>(cur :: Cursor<A>) -> Cursor<A>:
  ...
end

fun down<A>(cur :: Cursor<A>, child-index :: Number ) -> Cursor<A>:
  ...
end

fun update<A>(cur :: Cursor<A>, func :: (Tree<A> -> Tree<A>)) -> Cursor<A>:
  ...
end

fun to-tree<A>( cur :: Cursor<A> ) -> Tree<A>:
  ...
end

fun get-node-val<A>(cur :: Cursor<A>) -> Option<A>: 
  ...
end

